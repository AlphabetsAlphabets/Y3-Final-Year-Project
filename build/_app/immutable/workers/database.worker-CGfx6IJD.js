(function(){"use strict";/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const A=Symbol("Comlink.proxy"),q=Symbol("Comlink.endpoint"),W=Symbol("Comlink.releaseProxy"),R=Symbol("Comlink.finalizer"),p=Symbol("Comlink.thrown"),j=e=>typeof e=="object"&&e!==null||typeof e=="function",U={canHandle:e=>j(e)&&e[A],serialize(e){const{port1:t,port2:n}=new MessageChannel;return I(e,t),[n,[n]]},deserialize(e){return e.start(),X(e)}},F={canHandle:e=>j(e)&&p in e,serialize({value:e}){let t;return e instanceof Error?t={isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:t={isError:!1,value:e},[t,[]]},deserialize(e){throw e.isError?Object.assign(new Error(e.value.message),e.value):e.value}},N=new Map([["proxy",U],["throw",F]]);function D(e,t){for(const n of e)if(t===n||n==="*"||n instanceof RegExp&&n.test(t))return!0;return!1}function I(e,t=globalThis,n=["*"]){t.addEventListener("message",function a(s){if(!s||!s.data)return;if(!D(n,s.origin)){console.warn(`Invalid origin '${s.origin}' for comlink proxy`);return}const{id:l,type:m,path:d}=Object.assign({path:[]},s.data),f=(s.data.argumentList||[]).map(w);let i;try{const c=d.slice(0,-1).reduce((o,y)=>o[y],e),r=d.reduce((o,y)=>o[y],e);switch(m){case"GET":i=r;break;case"SET":c[d.slice(-1)[0]]=w(s.data.value),i=!0;break;case"APPLY":i=r.apply(c,f);break;case"CONSTRUCT":{const o=new r(...f);i=Y(o)}break;case"ENDPOINT":{const{port1:o,port2:y}=new MessageChannel;I(e,y),i=v(o,[o])}break;case"RELEASE":i=void 0;break;default:return}}catch(c){i={value:c,[p]:0}}Promise.resolve(i).catch(c=>({value:c,[p]:0})).then(c=>{const[r,o]=k(c);t.postMessage(Object.assign(Object.assign({},r),{id:l}),o),m==="RELEASE"&&(t.removeEventListener("message",a),S(t),R in e&&typeof e[R]=="function"&&e[R]())}).catch(c=>{const[r,o]=k({value:new TypeError("Unserializable return value"),[p]:0});t.postMessage(Object.assign(Object.assign({},r),{id:l}),o)})}),t.start&&t.start()}function _(e){return e.constructor.name==="MessagePort"}function S(e){_(e)&&e.close()}function X(e,t){const n=new Map;return e.addEventListener("message",function(s){const{data:l}=s;if(!l||!l.id)return;const m=n.get(l.id);if(m)try{m(l)}finally{n.delete(l.id)}}),P(e,n,[],t)}function T(e){if(e)throw new Error("Proxy has been released and is not useable")}function L(e){return g(e,new Map,{type:"RELEASE"}).then(()=>{S(e)})}const b=new WeakMap,h="FinalizationRegistry"in globalThis&&new FinalizationRegistry(e=>{const t=(b.get(e)||0)-1;b.set(e,t),t===0&&L(e)});function H(e,t){const n=(b.get(t)||0)+1;b.set(t,n),h&&h.register(e,t,e)}function z(e){h&&h.unregister(e)}function P(e,t,n=[],a=function(){}){let s=!1;const l=new Proxy(a,{get(m,d){if(T(s),d===W)return()=>{z(l),L(e),t.clear(),s=!0};if(d==="then"){if(n.length===0)return{then:()=>l};const f=g(e,t,{type:"GET",path:n.map(i=>i.toString())}).then(w);return f.then.bind(f)}return P(e,t,[...n,d])},set(m,d,f){T(s);const[i,c]=k(f);return g(e,t,{type:"SET",path:[...n,d].map(r=>r.toString()),value:i},c).then(w)},apply(m,d,f){T(s);const i=n[n.length-1];if(i===q)return g(e,t,{type:"ENDPOINT"}).then(w);if(i==="bind")return P(e,t,n.slice(0,-1));const[c,r]=M(f);return g(e,t,{type:"APPLY",path:n.map(o=>o.toString()),argumentList:c},r).then(w)},construct(m,d){T(s);const[f,i]=M(d);return g(e,t,{type:"CONSTRUCT",path:n.map(c=>c.toString()),argumentList:f},i).then(w)}});return H(l,e),l}function G(e){return Array.prototype.concat.apply([],e)}function M(e){const t=e.map(k);return[t.map(n=>n[0]),G(t.map(n=>n[1]))]}const x=new WeakMap;function v(e,t){return x.set(e,t),e}function Y(e){return Object.assign(e,{[A]:!0})}function k(e){for(const[t,n]of N)if(n.canHandle(e)){const[a,s]=n.serialize(e);return[{type:"HANDLER",name:t,value:a},s]}return[{type:"RAW",value:e},x.get(e)||[]]}function w(e){switch(e.type){case"HANDLER":return N.get(e.name).deserialize(e.value);case"RAW":return e.value}}function g(e,t,n,a){return new Promise(s=>{const l=B();t.set(l,s),e.start&&e.start(),e.postMessage(Object.assign({id:l},n),a)})}function B(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}globalThis.sqlite3Worker1Promiser=function e(t=e.defaultConfig){if(arguments.length===1&&typeof arguments[0]=="function"){const r=t;t=Object.assign(Object.create(null),e.defaultConfig),t.onready=r}else t=Object.assign(Object.create(null),e.defaultConfig,t);const n=Object.create(null),a=function(){},s=t.onerror||a,l=t.debug||a,m=t.generateMessageId?void 0:Object.create(null),d=t.generateMessageId||function(r){return r.type+"#"+(m[r.type]=(m[r.type]||0)+1)},f=(...r)=>{throw new Error(r.join(" "))};t.worker||(t.worker=e.defaultConfig.worker),typeof t.worker=="function"&&(t.worker=t.worker());let i,c;return t.worker.onmessage=function(r){r=r.data,l("worker1.onmessage",r);let o=n[r.messageId];if(!o){if(r&&r.type==="sqlite3-api"&&r.result==="worker1-ready"){t.onready&&t.onready(c);return}if(o=n[r.type],o&&o.onrow){o.onrow(r);return}t.onunhandled?t.onunhandled(arguments[0]):s("sqlite3Worker1Promiser() unhandled worker message:",r);return}switch(delete n[r.messageId],r.type){case"error":o.reject(r);return;case"open":i||(i=r.dbId);break;case"close":r.dbId===i&&(i=void 0);break}try{o.resolve(r)}catch(y){o.reject(y)}},c=function(){let r;arguments.length===1?r=arguments[0]:arguments.length===2?(r=Object.create(null),r.type=arguments[0],r.args=arguments[1],r.dbId=r.args.dbId):f("Invalid arguments for sqlite3Worker1Promiser()-created factory."),!r.dbId&&r.type!=="open"&&(r.dbId=i),r.messageId=d(r),r.departureTime=performance.now();const o=Object.create(null);o.message=r;let y;r.type==="exec"&&r.args&&(typeof r.args.callback=="function"?(y=r.messageId+":row",o.onrow=r.args.callback,r.args.callback=y,n[y]=o):typeof r.args.callback=="string"&&f("exec callback may not be a string when using the Promise interface."));let O=new Promise(function(ee,te){o.resolve=ee,o.reject=te,n[r.messageId]=o,l("Posting",r.type,"message to Worker dbId="+(i||"default")+":",r),t.worker.postMessage(r)});return y&&(O=O.finally(()=>delete n[y])),O}},globalThis.sqlite3Worker1Promiser.defaultConfig={worker:function(){return new Worker(new URL(""+new URL("sqlite3-worker1-bundler-friendly-DP-bqiTy.js",self.location.href).href,self.location.href),{type:"module"})},onerror:(...e)=>console.error("worker1 promiser error",...e)},sqlite3Worker1Promiser.v2=(function(e){let t;typeof e=="function"?(t=e,e={}):typeof(e==null?void 0:e.onready)=="function"&&(t=e.onready,delete e.onready);const n=Object.create(null);e=Object.assign(e||Object.create(null),{onready:async function(s){try{t&&await t(s),n.resolve(s)}catch(l){n.reject(l)}}});const a=new Promise(function(s,l){n.resolve=s,n.reject=l});try{this.original(e)}catch(s){n.reject(s)}return a}).bind({original:sqlite3Worker1Promiser});var V=sqlite3Worker1Promiser.v2;let u=null;function E(e){if(!e)throw new Error("Promiser not ready.")}let C=!1;const K=async()=>{C||(u=await V({onready:()=>{console.log("WORKER: SQLite promiser is ready.")}}),E(u),C=!0,await u("open",{filename:"time-tracker.db",vfs:"opfs"}),await u("exec",{sql:"PRAGMA foreign_keys = ON;"}))},$=async()=>{E(u),await u("exec",{sql:`
      CREATE TABLE IF NOT EXISTS activity (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS project (
        name TEXT PRIMARY KEY,
        color TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS log (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        activity TEXT NOT NULL,
        project_name TEXT,
        elapsed INTEGER NOT NULL,
        start INTEGER NOT NULL,
        end INTEGER NOT NULL,
        FOREIGN KEY (project_name) REFERENCES project(name) ON UPDATE CASCADE
      );
    `})},Q=async(e,t="",n="")=>{E(u);let a="SELECT";return t.length>0?a+=` ${t}`:a+=" *",a+=` FROM ${e}`,n.length>0&&(a+=` WHERE ${n}`),await u("exec",{sql:a,rowMode:"object"})},J=async(e,t,n)=>{E(u);const a=`INSERT INTO ${e} (${t}) VALUES (${n})`;console.log(a),await u("exec",{sql:a})},Z=async(e,t,n)=>{E(u);const a=`UPDATE ${e} SET ${t} WHERE ${n}`;return console.log(a),await u("exec",{sql:a})};I({async initWorker(){await K(),await $()},list:Q,insert:J,reset:async e=>{E(u),e?(await u("exec",{sql:`DROP TABLE IF EXISTS ${e};`}),console.log(`Table ${e} has been dropped`)):(await u("exec",{sql:`
        DROP TABLE IF EXISTS log;
        DROP TABLE IF EXISTS activity;
        DROP TABLE IF EXISTS project;
      `}),console.log("All tables have been dropped")),await $(),console.log("Tables have been recreated with fresh schema")},async listActivities(){var t;const e=await this.list("activity");return console.log("Received activities from worker.",e),((t=e==null?void 0:e.result)==null?void 0:t.resultRows)||[]},async addActivity(e){return await this.insert("activity","name",`'${e}'`),await this.listActivities()},async listProjects(){var t;const e=await this.list("project");return console.log("Received projects from worker",e),((t=e==null?void 0:e.result)==null?void 0:t.resultRows)||[]},async addProject(e,t){return await this.insert("project","name, color",`'${e}', '${t}'`),await this.listProjects()},async listLog(){const e=await this.list("log");console.log("Received logs from worker",e),e&&e.result&&e.result.resultRows||console.error("Something went wrong.");const t=e.result.resultRows;return Promise.all(t.map(async a=>{const s=await this.list("project","color",`name = '${a.project_name}'`);return a.project_color=s.result.resultRows[0].color,a}))||[]},async addLog(e,t,n,a,s){return await this.insert("log","activity, project_name, elapsed, start, end",`'${e}', '${t}', ${n}, ${a}, ${s}`),await this.listLog()},async updateProject(e,t){let n=await Z("project",`color = '${t}'`,`name = '${e}'`);console.log(n)}})})();
