(function(){"use strict";/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const P=Symbol("Comlink.proxy"),W=Symbol("Comlink.endpoint"),F=Symbol("Comlink.releaseProxy"),k=Symbol("Comlink.finalizer"),w=Symbol("Comlink.thrown"),A=e=>typeof e=="object"&&e!==null||typeof e=="function",D={canHandle:e=>A(e)&&e[P],serialize(e){const{port1:r,port2:t}=new MessageChannel;return R(e,r),[t,[t]]},deserialize(e){return e.start(),$(e)}},X={canHandle:e=>A(e)&&w in e,serialize({value:e}){let r;return e instanceof Error?r={isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:r={isError:!1,value:e},[r,[]]},deserialize(e){throw e.isError?Object.assign(new Error(e.value.message),e.value):e.value}},S=new Map([["proxy",D],["throw",X]]);function G(e,r){for(const t of e)if(r===t||t==="*"||t instanceof RegExp&&t.test(r))return!0;return!1}function R(e,r=globalThis,t=["*"]){r.addEventListener("message",function i(a){if(!a||!a.data)return;if(!G(t,a.origin)){console.warn(`Invalid origin '${a.origin}' for comlink proxy`);return}const{id:c,type:y,path:d}=Object.assign({path:[]},a.data),f=(a.data.argumentList||[]).map(T);let o;try{const l=d.slice(0,-1).reduce((s,E)=>s[E],e),n=d.reduce((s,E)=>s[E],e);switch(y){case"GET":o=n;break;case"SET":l[d.slice(-1)[0]]=T(a.data.value),o=!0;break;case"APPLY":o=n.apply(l,f);break;case"CONSTRUCT":{const s=new n(...f);o=V(s)}break;case"ENDPOINT":{const{port1:s,port2:E}=new MessageChannel;R(e,E),o=B(s,[s])}break;case"RELEASE":o=void 0;break;default:return}}catch(l){o={value:l,[w]:0}}Promise.resolve(o).catch(l=>({value:l,[w]:0})).then(l=>{const[n,s]=I(l);r.postMessage(Object.assign(Object.assign({},n),{id:c}),s),y==="RELEASE"&&(r.removeEventListener("message",i),L(r),k in e&&typeof e[k]=="function"&&e[k]())}).catch(l=>{const[n,s]=I({value:new TypeError("Unserializable return value"),[w]:0});r.postMessage(Object.assign(Object.assign({},n),{id:c}),s)})}),r.start&&r.start()}function _(e){return e.constructor.name==="MessagePort"}function L(e){_(e)&&e.close()}function $(e,r){const t=new Map;return e.addEventListener("message",function(a){const{data:c}=a;if(!c||!c.id)return;const y=t.get(c.id);if(y)try{y(c)}finally{t.delete(c.id)}}),O(e,t,[],r)}function p(e){if(e)throw new Error("Proxy has been released and is not useable")}function M(e){return g(e,new Map,{type:"RELEASE"}).then(()=>{L(e)})}const b=new WeakMap,h="FinalizationRegistry"in globalThis&&new FinalizationRegistry(e=>{const r=(b.get(e)||0)-1;b.set(e,r),r===0&&M(e)});function H(e,r){const t=(b.get(r)||0)+1;b.set(r,t),h&&h.register(e,r,e)}function z(e){h&&h.unregister(e)}function O(e,r,t=[],i=function(){}){let a=!1;const c=new Proxy(i,{get(y,d){if(p(a),d===F)return()=>{z(c),M(e),r.clear(),a=!0};if(d==="then"){if(t.length===0)return{then:()=>c};const f=g(e,r,{type:"GET",path:t.map(o=>o.toString())}).then(T);return f.then.bind(f)}return O(e,r,[...t,d])},set(y,d,f){p(a);const[o,l]=I(f);return g(e,r,{type:"SET",path:[...t,d].map(n=>n.toString()),value:o},l).then(T)},apply(y,d,f){p(a);const o=t[t.length-1];if(o===W)return g(e,r,{type:"ENDPOINT"}).then(T);if(o==="bind")return O(e,r,t.slice(0,-1));const[l,n]=j(f);return g(e,r,{type:"APPLY",path:t.map(s=>s.toString()),argumentList:l},n).then(T)},construct(y,d){p(a);const[f,o]=j(d);return g(e,r,{type:"CONSTRUCT",path:t.map(l=>l.toString()),argumentList:f},o).then(T)}});return H(c,e),c}function Y(e){return Array.prototype.concat.apply([],e)}function j(e){const r=e.map(I);return[r.map(t=>t[0]),Y(r.map(t=>t[1]))]}const C=new WeakMap;function B(e,r){return C.set(e,r),e}function V(e){return Object.assign(e,{[P]:!0})}function I(e){for(const[r,t]of S)if(t.canHandle(e)){const[i,a]=t.serialize(e);return[{type:"HANDLER",name:r,value:i},a]}return[{type:"RAW",value:e},C.get(e)||[]]}function T(e){switch(e.type){case"HANDLER":return S.get(e.name).deserialize(e.value);case"RAW":return e.value}}function g(e,r,t,i){return new Promise(a=>{const c=K();r.set(c,a),e.start&&e.start(),e.postMessage(Object.assign({id:c},t),i)})}function K(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}globalThis.sqlite3Worker1Promiser=function e(r=e.defaultConfig){if(arguments.length===1&&typeof arguments[0]=="function"){const n=r;r=Object.assign(Object.create(null),e.defaultConfig),r.onready=n}else r=Object.assign(Object.create(null),e.defaultConfig,r);const t=Object.create(null),i=function(){},a=r.onerror||i,c=r.debug||i,y=r.generateMessageId?void 0:Object.create(null),d=r.generateMessageId||function(n){return n.type+"#"+(y[n.type]=(y[n.type]||0)+1)},f=(...n)=>{throw new Error(n.join(" "))};r.worker||(r.worker=e.defaultConfig.worker),typeof r.worker=="function"&&(r.worker=r.worker());let o,l;return r.worker.onmessage=function(n){n=n.data,c("worker1.onmessage",n);let s=t[n.messageId];if(!s){if(n&&n.type==="sqlite3-api"&&n.result==="worker1-ready"){r.onready&&r.onready(l);return}if(s=t[n.type],s&&s.onrow){s.onrow(n);return}r.onunhandled?r.onunhandled(arguments[0]):a("sqlite3Worker1Promiser() unhandled worker message:",n);return}switch(delete t[n.messageId],n.type){case"error":s.reject(n);return;case"open":o||(o=n.dbId);break;case"close":n.dbId===o&&(o=void 0);break}try{s.resolve(n)}catch(E){s.reject(E)}},l=function(){let n;arguments.length===1?n=arguments[0]:arguments.length===2?(n=Object.create(null),n.type=arguments[0],n.args=arguments[1],n.dbId=n.args.dbId):f("Invalid arguments for sqlite3Worker1Promiser()-created factory."),!n.dbId&&n.type!=="open"&&(n.dbId=o),n.messageId=d(n),n.departureTime=performance.now();const s=Object.create(null);s.message=n;let E;n.type==="exec"&&n.args&&(typeof n.args.callback=="function"?(E=n.messageId+":row",s.onrow=n.args.callback,n.args.callback=E,t[E]=s):typeof n.args.callback=="string"&&f("exec callback may not be a string when using the Promise interface."));let N=new Promise(function(ee,re){s.resolve=ee,s.reject=re,t[n.messageId]=s,c("Posting",n.type,"message to Worker dbId="+(o||"default")+":",n),r.worker.postMessage(n)});return E&&(N=N.finally(()=>delete t[E])),N}},globalThis.sqlite3Worker1Promiser.defaultConfig={worker:function(){return new Worker(new URL(""+new URL("sqlite3-worker1-bundler-friendly-DP-bqiTy.js",self.location.href).href,self.location.href),{type:"module"})},onerror:(...e)=>console.error("worker1 promiser error",...e)},sqlite3Worker1Promiser.v2=(function(e){let r;typeof e=="function"?(r=e,e={}):typeof(e==null?void 0:e.onready)=="function"&&(r=e.onready,delete e.onready);const t=Object.create(null);e=Object.assign(e||Object.create(null),{onready:async function(a){try{r&&await r(a),t.resolve(a)}catch(c){t.reject(c)}}});const i=new Promise(function(a,c){t.resolve=a,t.reject=c});try{this.original(e)}catch(a){t.reject(a)}return i}).bind({original:sqlite3Worker1Promiser});var v=sqlite3Worker1Promiser.v2;const Q=[`
  CREATE TABLE IF NOT EXISTS activity (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL
  );
`,`
  CREATE TABLE IF NOT EXISTS project (
  name TEXT PRIMARY KEY,
  color TEXT NOT NULL
  );
`,`
  CREATE TABLE IF NOT EXISTS log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  activity TEXT NOT NULL,
  project_name TEXT,
  elapsed INTEGER NOT NULL,
  start INTEGER NOT NULL,
  end INTEGER NOT NULL,
  FOREIGN KEY (project_name) REFERENCES project(name) ON UPDATE CASCADE
  );
`,`
CREATE TABLE IF NOT EXISTS tasks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  description TEXT,
  completed INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  completed_at INTEGER
);
`];let u=null;function m(e){if(!e)throw new Error("Promiser not ready.")}let x=!1;const J=async()=>{x||(u=await v({onready:()=>{console.log("WORKER: SQLite promiser is ready.")}}),m(u),x=!0,await u("open",{filename:"time-tracker.db",vfs:"opfs"}),await u("exec",{sql:"PRAGMA foreign_keys = ON;"}))},q=async()=>{m(u);const e=Q.join(`
`);await u("exec",{sql:e})},Z=(e,r)=>{let t="";return e.length>0?t+=` ${e}`:t+=" *",t+=` FROM ${r}`,t},U=e=>{let r="";return e.length>0&&(r+=` WHERE ${e}`),r};R({list:async(e,r="",t="")=>{m(u);let i="SELECT";return i+=Z(r,e),i+=U(t),await u("exec",{sql:i,rowMode:"object"})},insert:async(e,r,t)=>{m(u);const i=`INSERT INTO ${e} (${r}) VALUES (${t})`;console.log(i),await u("exec",{sql:i})},reset:async e=>{m(u),e?(await u("exec",{sql:`DROP TABLE IF EXISTS ${e};`}),console.log(`Table ${e} has been dropped`)):(await u("exec",{sql:`
        DROP TABLE IF EXISTS log;
        DROP TABLE IF EXISTS activity;
        DROP TABLE IF EXISTS project;
        DROP TABLE IF EXISTS tasks;
      `}),console.log("All tables have been dropped")),await q(),console.log("Tables have been recreated with fresh schema")},update:async(e,r,t)=>{m(u);const i=`UPDATE ${e} SET ${r} WHERE ${t}`;return console.log(i),await u("exec",{sql:i})},remove:async(e,r)=>{m(u);let t=`DELETE FROM ${e}`;return t+=U(r),await u("exec",{sql:t,rowMode:"object"})},async initWorker(){await J(),await q()}})})();
