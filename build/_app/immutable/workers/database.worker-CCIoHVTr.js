(function(){"use strict";/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const O=Symbol("Comlink.proxy"),D=Symbol("Comlink.endpoint"),X=Symbol("Comlink.releaseProxy"),R=Symbol("Comlink.finalizer"),w=Symbol("Comlink.thrown"),A=e=>typeof e=="object"&&e!==null||typeof e=="function",G={canHandle:e=>A(e)&&e[O],serialize(e){const{port1:t,port2:r}=new MessageChannel;return k(e,t),[r,[r]]},deserialize(e){return e.start(),z(e)}},_={canHandle:e=>A(e)&&w in e,serialize({value:e}){let t;return e instanceof Error?t={isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:t={isError:!1,value:e},[t,[]]},deserialize(e){throw e.isError?Object.assign(new Error(e.value.message),e.value):e.value}},S=new Map([["proxy",G],["throw",_]]);function $(e,t){for(const r of e)if(t===r||r==="*"||r instanceof RegExp&&r.test(t))return!0;return!1}function k(e,t=globalThis,r=["*"]){t.addEventListener("message",function i(a){if(!a||!a.data)return;if(!$(r,a.origin)){console.warn(`Invalid origin '${a.origin}' for comlink proxy`);return}const{id:c,type:y,path:d}=Object.assign({path:[]},a.data),f=(a.data.argumentList||[]).map(m);let o;try{const u=d.slice(0,-1).reduce((s,E)=>s[E],e),n=d.reduce((s,E)=>s[E],e);switch(y){case"GET":o=n;break;case"SET":u[d.slice(-1)[0]]=m(a.data.value),o=!0;break;case"APPLY":o=n.apply(u,f);break;case"CONSTRUCT":{const s=new n(...f);o=v(s)}break;case"ENDPOINT":{const{port1:s,port2:E}=new MessageChannel;k(e,E),o=K(s,[s])}break;case"RELEASE":o=void 0;break;default:return}}catch(u){o={value:u,[w]:0}}Promise.resolve(o).catch(u=>({value:u,[w]:0})).then(u=>{const[n,s]=I(u);t.postMessage(Object.assign(Object.assign({},n),{id:c}),s),y==="RELEASE"&&(t.removeEventListener("message",i),j(t),R in e&&typeof e[R]=="function"&&e[R]())}).catch(u=>{const[n,s]=I({value:new TypeError("Unserializable return value"),[w]:0});t.postMessage(Object.assign(Object.assign({},n),{id:c}),s)})}),t.start&&t.start()}function H(e){return e.constructor.name==="MessagePort"}function j(e){H(e)&&e.close()}function z(e,t){const r=new Map;return e.addEventListener("message",function(a){const{data:c}=a;if(!c||!c.id)return;const y=r.get(c.id);if(y)try{y(c)}finally{r.delete(c.id)}}),N(e,r,[],t)}function p(e){if(e)throw new Error("Proxy has been released and is not useable")}function L(e){return g(e,new Map,{type:"RELEASE"}).then(()=>{j(e)})}const b=new WeakMap,h="FinalizationRegistry"in globalThis&&new FinalizationRegistry(e=>{const t=(b.get(e)||0)-1;b.set(e,t),t===0&&L(e)});function Y(e,t){const r=(b.get(t)||0)+1;b.set(t,r),h&&h.register(e,t,e)}function B(e){h&&h.unregister(e)}function N(e,t,r=[],i=function(){}){let a=!1;const c=new Proxy(i,{get(y,d){if(p(a),d===X)return()=>{B(c),L(e),t.clear(),a=!0};if(d==="then"){if(r.length===0)return{then:()=>c};const f=g(e,t,{type:"GET",path:r.map(o=>o.toString())}).then(m);return f.then.bind(f)}return N(e,t,[...r,d])},set(y,d,f){p(a);const[o,u]=I(f);return g(e,t,{type:"SET",path:[...r,d].map(n=>n.toString()),value:o},u).then(m)},apply(y,d,f){p(a);const o=r[r.length-1];if(o===D)return g(e,t,{type:"ENDPOINT"}).then(m);if(o==="bind")return N(e,t,r.slice(0,-1));const[u,n]=M(f);return g(e,t,{type:"APPLY",path:r.map(s=>s.toString()),argumentList:u},n).then(m)},construct(y,d){p(a);const[f,o]=M(d);return g(e,t,{type:"CONSTRUCT",path:r.map(u=>u.toString()),argumentList:f},o).then(m)}});return Y(c,e),c}function V(e){return Array.prototype.concat.apply([],e)}function M(e){const t=e.map(I);return[t.map(r=>r[0]),V(t.map(r=>r[1]))]}const C=new WeakMap;function K(e,t){return C.set(e,t),e}function v(e){return Object.assign(e,{[O]:!0})}function I(e){for(const[t,r]of S)if(r.canHandle(e)){const[i,a]=r.serialize(e);return[{type:"HANDLER",name:t,value:i},a]}return[{type:"RAW",value:e},C.get(e)||[]]}function m(e){switch(e.type){case"HANDLER":return S.get(e.name).deserialize(e.value);case"RAW":return e.value}}function g(e,t,r,i){return new Promise(a=>{const c=Q();t.set(c,a),e.start&&e.start(),e.postMessage(Object.assign({id:c},r),i)})}function Q(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}globalThis.sqlite3Worker1Promiser=function e(t=e.defaultConfig){if(arguments.length===1&&typeof arguments[0]=="function"){const n=t;t=Object.assign(Object.create(null),e.defaultConfig),t.onready=n}else t=Object.assign(Object.create(null),e.defaultConfig,t);const r=Object.create(null),i=function(){},a=t.onerror||i,c=t.debug||i,y=t.generateMessageId?void 0:Object.create(null),d=t.generateMessageId||function(n){return n.type+"#"+(y[n.type]=(y[n.type]||0)+1)},f=(...n)=>{throw new Error(n.join(" "))};t.worker||(t.worker=e.defaultConfig.worker),typeof t.worker=="function"&&(t.worker=t.worker());let o,u;return t.worker.onmessage=function(n){n=n.data,c("worker1.onmessage",n);let s=r[n.messageId];if(!s){if(n&&n.type==="sqlite3-api"&&n.result==="worker1-ready"){t.onready&&t.onready(u);return}if(s=r[n.type],s&&s.onrow){s.onrow(n);return}t.onunhandled?t.onunhandled(arguments[0]):a("sqlite3Worker1Promiser() unhandled worker message:",n);return}switch(delete r[n.messageId],n.type){case"error":s.reject(n);return;case"open":o||(o=n.dbId);break;case"close":n.dbId===o&&(o=void 0);break}try{s.resolve(n)}catch(E){s.reject(E)}},u=function(){let n;arguments.length===1?n=arguments[0]:arguments.length===2?(n=Object.create(null),n.type=arguments[0],n.args=arguments[1],n.dbId=n.args.dbId):f("Invalid arguments for sqlite3Worker1Promiser()-created factory."),!n.dbId&&n.type!=="open"&&(n.dbId=o),n.messageId=d(n),n.departureTime=performance.now();const s=Object.create(null);s.message=n;let E;n.type==="exec"&&n.args&&(typeof n.args.callback=="function"?(E=n.messageId+":row",s.onrow=n.args.callback,n.args.callback=E,r[E]=s):typeof n.args.callback=="string"&&f("exec callback may not be a string when using the Promise interface."));let P=new Promise(function(se,ae){s.resolve=se,s.reject=ae,r[n.messageId]=s,c("Posting",n.type,"message to Worker dbId="+(o||"default")+":",n),t.worker.postMessage(n)});return E&&(P=P.finally(()=>delete r[E])),P}},globalThis.sqlite3Worker1Promiser.defaultConfig={worker:function(){return new Worker(new URL(""+new URL("sqlite3-worker1-bundler-friendly-DP-bqiTy.js",self.location.href).href,self.location.href),{type:"module"})},onerror:(...e)=>console.error("worker1 promiser error",...e)},sqlite3Worker1Promiser.v2=(function(e){let t;typeof e=="function"?(t=e,e={}):typeof(e==null?void 0:e.onready)=="function"&&(t=e.onready,delete e.onready);const r=Object.create(null);e=Object.assign(e||Object.create(null),{onready:async function(a){try{t&&await t(a),r.resolve(a)}catch(c){r.reject(c)}}});const i=new Promise(function(a,c){r.resolve=a,r.reject=c});try{this.original(e)}catch(a){r.reject(a)}return i}).bind({original:sqlite3Worker1Promiser});var J=sqlite3Worker1Promiser.v2;const Z=[`
  CREATE TABLE IF NOT EXISTS activity (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL
  );
`,`
  CREATE TABLE IF NOT EXISTS project (
  name TEXT PRIMARY KEY,
  color TEXT NOT NULL
  );
`,`
  CREATE TABLE IF NOT EXISTS log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  activity TEXT NOT NULL,
  project_name TEXT,
  elapsed INTEGER NOT NULL,
  start INTEGER NOT NULL,
  end INTEGER NOT NULL,
  FOREIGN KEY (project_name) REFERENCES project(name) ON UPDATE CASCADE
  );
`,`
CREATE TABLE IF NOT EXISTS tasks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  description TEXT,
  completed INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  completed_at INTEGER
);
`];let l=null;function T(e){if(!e)throw new Error("Promiser not ready.")}let x=!1;const ee=async()=>{x||(l=await J({onready:()=>{console.log("WORKER: SQLite promiser is ready.")}}),T(l),x=!0,await l("open",{filename:"time-tracker.db",vfs:"opfs"}),await l("exec",{sql:"PRAGMA foreign_keys = ON;"}))},te=async()=>{T(l);const e=await W("project","*","name = 'No Project'");e.result&&e.result.resultRows&&e.result.resultRows.length===0&&(await F("project","name, color","'No Project', '#000000'"),console.log("Default 'No Project' project created"))},q=async()=>{T(l);const e=Z.join(`
`);await l("exec",{sql:e}),await te()},re=(e,t)=>{let r="";return e.length>0?r+=` ${e}`:r+=" *",r+=` FROM ${t}`,r},U=e=>{let t="";return e.length>0&&(t+=` WHERE ${e}`),t},ne=async(e,t)=>{T(l);let r=`DELETE FROM ${e}`;return r+=U(t),await l("exec",{sql:r,rowMode:"object"})},W=async(e,t="",r="")=>{T(l);let i="SELECT";return i+=re(t,e),i+=U(r),await l("exec",{sql:i,rowMode:"object"})},F=async(e,t,r)=>{T(l);const i=`INSERT INTO ${e} (${t}) VALUES (${r})`;console.log(i),await l("exec",{sql:i})};k({list:W,insert:F,reset:async e=>{T(l),e?(await l("exec",{sql:`DROP TABLE IF EXISTS ${e};`}),console.log(`Table ${e} has been dropped`)):(await l("exec",{sql:`
        DROP TABLE IF EXISTS log;
        DROP TABLE IF EXISTS activity;
        DROP TABLE IF EXISTS project;
        DROP TABLE IF EXISTS tasks;
      `}),console.log("All tables have been dropped")),await q(),console.log("Tables have been recreated with fresh schema")},update:async(e,t,r)=>{T(l);const i=`UPDATE ${e} SET ${t} WHERE ${r}`;return console.log(i),await l("exec",{sql:i})},remove:ne,async initWorker(){await ee(),await q()}})})();
